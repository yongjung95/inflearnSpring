## 07. 고급 동기화 - concurrent.Lock

### synchronized 단점
- 무한 대기 
  - **BLOCKED** 상태의 스레드는 락이 풀릴 때 까지 무한 대기한다.
  - 특정 시간까지만 대기하는 타임아웃❌
  - 중간에 인터럽트❌
- 공정성 
  - 락이 돌아왔을 때 **BLOCKED** 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할 지 알 수 없다.
  - 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다.


## LockSupport 기능
- **LockSupport** 는 스레드를 **WAITING** 상태로 변경한다.
- **WATING** 상태는 누가 깨워주기 전까지는 계속 대기한다.
  - 그리고 CPU 실행 스케줄링에 들어가지 않는다.


### LockSupport 의 대표적인 기능
- **park()**
  - 스레드를 **WAITING** 상태로 변경한다.
  - 스레드를 대기 상태로 둔다.
- **parkNanos(nanos)**
  - 스레드를 나노초 동안만 **TIMED_WAITING** 상태로 변경한다.
  - 지정한 나노초가 지나면 **TIMED_WAITING** 상태에서 빠져나오고 **RUNNABLE** 상태로 변경된다.
- **unpark(thread)**
  - **WAITNG** 상태의 대상 스레드를 **RUNNABLE** 상태로 변경한다.


## BLOCKED VS WAITING
### 인터럽트
- **BLOCKED**
  - 인터럽트가 걸려도 대기 상태를 빠져나오지 못한다.
  - 여전히 **BLOCKED** 상태이다.
- **WAITING**, **TIMED_WAITING**
  - 인터럽트가 걸리면 대기 상태를 빠져나온다.
  - 그래서 **RUNNABLE** 상태로 변한다.


### 용도
- **BLOCKED** 
  - 자바의 **synchronized** 에서 락을 획득하기 위해 대기할 때 사용된다.
- **WAITING**, **TIME_WAITING**
  - 스레드가 특정 조건이나 시간 동안 대기할 때 발생하는 상태이다.
  - 다양한 상황에서 사용된다.
    - 예) **Thread.join()**, **LockSupport.park()**, **Object.wait()** 와 같은 메서드 호출 시 **WAITING** 상태가 된다.
  - **TIME_WAITING** 상태는 시간 제한이 있는 대기 메서드를 호출할 때 발생한다.


### 정리
- **BLOCKED**, **WAITIN**, **TIMED_WAITING** 상태 모두 스레드가 대기하며, 실행 스케줄링에 들어가지 않기 때문에 CPU 입장에서 보면 실행하지 않는 비슷한 상태이다.
  - **BLOCKED** 상태는 **synchronized** 에서만 사용하는 특별한 대기 상태라고 이해하면 된다.
  - **WAITING**, **TIMED_WAITING** 상태는 범용적으로 활용할 수 있는 대기 상태라고 이해하면 된다.


## ReentrantLock
- 자바 1.0 부터 존재한 **synchronized** 와 **BLOCKED** 상태를 통한 임계 영역 관리의 한계를 극복하기 위해 자바 1.5부터 **Lock** 인터페이스와 **ReentrantLock** 구현체를 제공한다.


### Lock 인터페이스
- 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데 사용된다.
- 대표적인 구현체로 **ReentrantLock**이 있다.

### 주요 메서드
- void lock()
  - 락을 획득한다. 
  - 만약 다른 스레드가 이미 락을 획득했다면, 락이 풀릴 때까지 현재 스레드는 대기한다.
  - 이 메서드는 인터럽트에 응답하지 않는다.
- void lockInterruptibly()
  - 락 획득을 시도하되, 다른 스레드가 인터럽트할 수 있도록 한다.
  - 만약 다른 스레드가 이미 락을 획득했다면, 현재 스레드는 락을 획득할 때까지 대기한다.
  - 대기 중에 인터럽트가 발생하면 **InterruptedException**이 발생하며 락 획득을 포기한다.
- boolean tryLock()
  - 락 획득을 시도하고, 즉시 성공 여부를 반환한다.
  - 만약 다른 스레드가 이미 락을 획득했다면 **false**를 반환하고, 그렇지 않으면 락을 획득하고 **true**를 반환한다.
- boolean tryLock(long time, TimeUnit unit)
  - 주어진 시간 동안 락 획득을 시도한다.
  - 주어진 시간 안에 락을 획득하면 **true**를 반환한다.
  - 주어진 시간이 지나도 락을 획득하지 못한 경우 **false**를 반환한다.
  - 이 메서드는 대기 중 인터럽트가 발생하면 **InterruptedException**이 발생하며 락 획득을 포기한다.
- void unlock()
  - 락을 해제한다.
  - 락을 해제하면 락 획득을 대기 중인 스레드 중 하나가 락을 획득할 수 있게 된다.
  - 락을 획득한 스레드가 호출해야 하며, 그렇지 않으면 **IllegalMonitorStateException** 이 발생할 수 있다.
- Condition newCondition()
  - **Condition** 객체를 생성하여 반환한다.
  - **Condition** 객체는 락과 결합되어 사용되며, 스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 한다.
  - 이는 **Object** 클래스의 **wait**, **notify**, **notifyAll** 메서드와 유사한 역할을 한다.


### 주의
- 여기서 사용하는 락은 객체 내부에 있는 모니터 락이 아니다.
- **Lock** 인터페이스와 **ReentrantLock**이 제공하는 기능이다.


## 공정성
### 비공정 모드 (Non-fair mode)
- 비공정 모드는 **ReentrantLock**의 기본 모드이다.
- 이 모드에서는 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이 없다.
- 락을 풀었을 때, 대기 중인 스레드 중 아무나 락을 획득할 수 있다.
- 이는 락을 빨리 획득할 수 있지만, 특정 스레드가 장기간 락을 획득하지 못할 가능성도 있다.


### 비공정 모드 특징
- 성능 우선
  - 락을 획득하는 속도가 빠르다.
- 선점 가능
  - 새로운 스레드가 기존 대기 스레드보다 먼저 락을 획득할 수 있다.
- 기아 현상 가능성
  - 특정 스레드가 계속해서 락을 획득하지 못할 수 있다.


### 공정 모드 (Fair mode)
- 공정 모드는 락을 요청한 순서대로 스레드가 락을 획득할 수 있게 한다.
- 이는 먼저 대기한 스레드가 먼저 락을 획득하게 되어 스레드 간의 공정성을 보장한다.
- 그러나 이로 인해 성능이 저하될 수 있다.


### 공정 모드 특징
- 공정성 보장
  - 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득한다.
- 기아 현상 방지
  - 모든 스레드가 언젠가 락을 획득할 수 있게 보장된다.
- 성능 저하
  - 락을 획득하는 속도가 느려질 수 있다.


### 비공정, 공정 모드 정리
- **비공정 모드**
  - 성능을 중시하고, 스레드가 락을 빨리 획득할 수 있지만, 특정 스레드가 계속해서 락을 획득하지 못할 수 있다.
- **공정 모드**
  - 스레드가 락을 획득하는 순서를 보장하여 공정성을 중시하지만, 성능이 저하될 수 있다.


### 정리
- **Lock** 인터페이스와 **ReentrantLock** 구현체를 사용하면 **synchronized** 단점인 무한 대기와 공정성 문제를 모두 해결할 수 있다.