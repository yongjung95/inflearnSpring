## 스레드 제어와 생명 주기2
### 인터럽트
- 특정 스레드가 **Thread.sleep()** 을 통해 쉬고 있는데, 처리해야 하는 작업이 들어와서 해당 스레드를 급하게 깨워야 할 때 사용한다.
- **WAITING**, **TIMED_WAITING** 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 **RUNNABLE** 상태로 만들 수 있다.


### 주의
- 자바에서 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상(false)으로 돌리는 것은 이런 이유 때문이다.
- 스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.
- 인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.
  - 인터럽트의 상태를 직접 체크해서 사용하는 경우 **Thread.interrupted()** 를 사용하면 이런 부분이 해결된다.
  - 참고로 **isInterrupted()** 는 특정 스레드의 상태를 변경하지 않고 확인할 때 사용한다.


## yield
- 어떤 스레드를 얼마나 실행할지는 운영체제가 스케줄링을 통해 결정한다.
  - 그런제 특정 스레드가 크게 바쁘지 않은 상황이어서 다른 스레드에 CPU 실행 기회를 양보하고 싶을 수 있다.
  - 이렇게 양보하면 스케줄링 큐에 대기 중인 다른 스레드가 CPU 실행 기회를 더 빨리 얻을 수 있다.

### 자바의 스레드가 **RUNNABLE** 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태를 가질 수 있다.
- **실행 상태(Running)**
  - 스레드가 CPU에서 실행 중이다.
- **실행 대기 상태(Ready)**
  - 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중이다.

### sleep() 방식
- **RUNNABLE** -> **TIMED_WAITING** -> **RUNNABLE** 로 변경되는 복잡한 과정을 거치고, 또 특정 시간 만큼 스레드가 실행되지 않는 단점이 있다.
  - 예) 양보할 스레드가 없다면, 차라리 나의 스레드를 더 실행하는 것이 나은 선택일 수 있다.
- 이 방법은 나머지 스레드가 모두 대기 상태로 쉬고 있어도 내 스레드까지 잠깐 실행되지 않는 것이다. 쉽게 이야기해서 양보할 사람이 없는데 혼자서 양보한 이상한 상황이 될 수 있다.


### yield 방식
- **Thread.yield()** 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
- 메서드를 호출한 스레드는 **RUNNABLE** 상태를 유지하면서 CPU를 양보한다.
  - 즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.
- 자바에서 **Thread.yield()** 메서드를 호출하면 현재 실행 중인 스레드가 CPU를 양보하도록 힌트를 준다
  - 이는 스레드가 자신에게 할당된 실행 시간을 포기하고 다른 스레드에게 실행 기회를 주도록 한다.
  - 참고로 이 메서드는 운영체제의 스케줄러에게 단지 힌트를 제공할 뿐, **강제적인 실행 순서를 지정하지 않는다.**
- **yield()** 는 **RUNNABLE** 상태를 유지하기 때문에, 쉽게 이야기해서 양보할 사람이 없다면 본인 스레드가 계속 실행될 수 있다.