## 02. 스레드 생성과 실행
## 스레드 시작1

### 자바 메모리 구조
![img_1.png](images/자바%20메모리%20구조.png)
- **메서드 영역(Method Area)**
  - 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리한다.
  - 이 영역은 **프로그램의 모든 영역에서 공유**한다.
  - 클래스 정보
    - 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등 모든 실행 코드가 존재한다.
  - static 영역
    - **static** 변수들을 보관한다.
  - 런타임 상수 풀
    - 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다.
- **스택 영역(Stack Area)**
  - 자바 실행 시, 하나의 실행 스택이 생성된다.
  - 각 스탬 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.
  - 스택 프레임
    - 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임이다.
    - 메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.
- **힙 영역(Heap Area)**
  - 객체(인스턴스)와 배열이 생성되는 영역이다.
  - 가비지 컬렉션(GC)이 이루어지는 중요 영역이며, **더 이상 참조되지 않는 객체는 GC에 의해 제거**된다.


### 정리
- **main 스레드는 단지 새로운 스레드에게 실행을 지시**할 뿐이다.
- 스레드 간 실행 순서는 보장하지 않는다.


## 데몬 스레드
### 스레드 종류
- **사용자 스레드(non-daemon 스레드)**
  - 프로그램의 주요 작업을 수행한다.
  - 작업이 완료될 때까지 실행된다.
  - 모든 user 스레드가 종료되면 JVM도 종료된다.
- **데몬 스레드(daemon 스레드)**
  - 백그라운드에서 보조적인 작업을 수행한다.
  - 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.


## 스레드 생성 - Runnable
- 스레드를 만들 때는 **Thread** 클래스를 상속 받는 방법과 **Runnable** 인터페이스를 구현하는 방법이 있다.

### Thread 상속 VS Runnable 구현
- 스레드 사용할 때는 **Thread** 클래스를 상속 받는 방법보다 **Runnable** 인터페이스를 구현하는 방식을 사용하다.

### Thread 클래스 상속 방식
- 장점
  - 간단한 구현 
    -  **Thread** 클래스를 상속받아 **run()** 메서드만 재정의하면 된다.
- 단점
  - 상속의 제한 
    - 자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속 받고 있는 경우 **Thread** 클래스를 상속 받을 수 없다.
  - 유연성 부족 
    - 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.

### Runnable 인터페이스를 구현 방식
- 장점
  - 상속의 자유로움 
    - **Runnable** 인터페이스 방식은 다른 클래스를 상속 받아도 문제 없이 구현할 수 있다.
  - 코드의 분리 
    - 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
  - 여러 스레드가 동일한 **Runnable** 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
- 단점
  - 코드가 약간 복잡해질 수 있다.
    - **Runnable** 객체를 생성하고 이를 **Thread**에 전달하는 과정이 추가된다.

### 정리
- **Runnable** 인터페이스를 구현하는 방식을 사용하자.
- 스레드와 실행할 작업을 명확히 분리하고, 인터페이스를 사용하므로 **Thread** 클래스를 직접 상속하는 방식보다 더 유연하고 유지보수 하기 쉬운 코드를 만들 수 있다.