## 10. CAS - 동기화와 원자적 연산

## 원자적 연산 - 소개
- 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다.
  - 쉽게 이야기해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻이다.
- 원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다.
  - 하지만 원자적 연산이 아닌 경우에는 `synchronized` 블럭이나 `Lock` 등을 사용해서 안전한 임계 영역을 만들어야 한다.
- 예) `i = 1`


## 원자적 연산 - AtomicInteger
- 자바는 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는 `AtomicInteger` 라는 클래스를 제공한다.
  - 이름 그대로 원자적인 `Integer` 라는 뜻이다.
- `AtomicInteger`는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다.
  - 특정 값을 증가하거나 감소해야 하는데 여러 스레드가 해당 값을 공유해야 한다면, `AtomicInteger`를 사용하면 된다.
- 락을 사용하지 않고, 원자적 연산을 만들어 내기 때문에 락 방식 보다 성능이 빠르다.
- 참고
  - `AtomicInteger` , `AtomicLong` , `AtomicBoolean` 등 다양한 `AtomicXxx` 클래스가 존재한다.


## CAS 연산
### 락 기반 방식의 문제점
- 락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한한다.
- 락이 걸려 있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 한다.
- 또한 락 기반 접근에서는 락을 획득하고 해제하는 데 시간이 소요된다.
- 예)
  - 락이 있는지 확인한다.
  - 락을 획득하고 임계 영역에 들어간다.
  - 작업을 수행한다.
  - 락을 반납한다.
  

### CAS
- 락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법이다.
- 이 방법은 락을 사용하지 않기 때문에 락 프리 기법이라 한다.
  - 참고로 CAS 연산은 락을 완전히 대체하는 것은 아니고, **작은 단위의 일부 영역에 적용**할 수 있다.
  - 기본은 락을 사용하고, 특별한 경우에 CAS를 적용할 수 있다고 생각하면 된다.


### CAS 실행 분석
![img.png](images/CAS%20실행%20분석.png)


### CPU 하드웨어의 지원
- CAS 연산은 이렇게 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능이다. 
- 이것은 소프트웨어가 제공하는 기능이 아니라 하드웨어가 제공하는 기능이다.
- 대부분의 현대 CPU들은 CAS 연산을 위한 명령어를 제공한다.


## CAS와 락 방식의 비교
### 락(Lock) 방식
- 비관적 접근법
- 데이터에 접근하기 전에 항상 락을 획득
- 다른 스레드의 접근을 막음
- "다른 스레드가 방해할 것이다"라고 가정


### CAS 방식
- 낙관적 접근법
- 락을 사용하지 않고 데이터에 바로 접근
- 충돌이 발생하면 그때 재시도
- "대부분의 경우 충돌이 없을 것이다"라고 가정
- 간단한 CPU 연산에 효과적


## CAS 단점
- 이 방식은 락을 기다리는 스레드가 **BLOCKED**, **WAITING** 상태로 빠지지는 않지만, **RUNNABLE** 상태로 락을 획득 할 때까지 CPU를 계속 사용하면서 대기하는 것이다.
  - 만약 동기화 락을 사용하면 이 사이에 CPU 자원을 거의 사용하지 않을 수 있다.
- 그래서 동기화 락을 사용하는 방식보다 스레드를 **RUNNBALE**로 살려둔 상태에서 계속 락 획득을 반복 체크하는 것이 더 효율적인 경우에 이런 방식을 사용해야 한다.
  - 이 방식은 스레드의 상태가 변경되지 않기 때문에 매우 빠르게 락을 획득하고, 또 바로 실행할 수 있는 장점이 있다.


### CAS 사용처
- 안전한 임계 영역이 필요하지만, 연산이 길지 않고 매우매우매우! 짧게 끝날 때 사용해야 한다.
- 예) 숫자 값의 증가, 자료 구조의 데이터 추가와 같이 CPU 사이클이 금방 끝나는 연산에 사용하면 효과적이다.


## 정리
### 락 VS CAS 사용 방식
- CAS의 장점
  - 낙관적 동기화
    - 락을 걸지 않고도 값을 안전하게 업데이트할 수 있다.
    - CAS는 충돌이 자주 발생하지 않을 것이라고 가정한다.
    - 이는 충돌이 적은 환경에서 높은 성능을 발휘한다.
  - 락 프리
    - CAS는 락을 사용하지 않기 때문에, 락을 획득하기 위해 대기하는 시간이 많다.
    - 따라서 스레드가 블로킹 되지 않으며, 병렬 처리가 더 효율적일 수 있다.
- CAS의 단점
  - 충돌이 빈번한 경우
    - 여러 스레드가 동시에 동일한 변수에 접근하여 업데이트를 시도할 때 충돌이 발생할 수 있다.
    - 충돌이 발생하면 CAS는 루프를 돌며 재시도해야 하며, 이에 따라 CPU 자원을 계속 소모할 수 있다. 
    - 반복적인 재시도로 인해 오버헤드가 발생할 수 있다.
  - 스핀락과 유사한 오버헤드
    - CAS는 충돌 시 반복적인 재시도를 하므로, 이 과정이 계속 반복되면 스핀락과 유사한 성능 저하가 발생할 수 있다.
    - 특히 충돌 빈도가 높을수록 이런 현상이 두드러진다.
- 동기화 락의 장점
  - 충돌 관리
    - 락을 사용하면 하나의 스레드만 리소스에 접근할 수 있으므로 충돌이 발생하지 않는다. 
    - 여러 스레드가 경쟁할 경우에도 안정적으로 동작한다.
  - 안정성
    - 복잡한 상황에서도 락은 일관성 있는 동작을 보장한다.
  - 스레드 대기
    - 락을 대기하는 스레드는 CPU를 거의 사용하지 않는다.
- 동기화 락의 단점
  - 락 획득 대기 시간
    - 스레드가 락을 획득하기 위해 대기해야 하므로, 대기 시간이 길어질 수 있다.
  - 컨텍스트 스위칭 오버헤드
    - 락을 사용하면, 락 획득을 대기하는 시점과 또 락을 획득하는 시점에 스레드의 상태가 변경된다. 
    - 이때 컨텍스트 스위칭이 발생할 수 있으며, 이로 인해 오버헤드가 증가할 수 있다. 