## 08. 생산자 소비자 문제1

## 기본 개념
- 생산자
  - 데이터를 생성하는 역할을 한다.
    - 예) 파일에서 데이터를 읽어오거나 네트워크에서 데이터를 받아오는 스레드가 생산자 역할을 할 수 있다.
- 소비자
  - 생성된 데이터를 사용하는 역할을 한다
    - 예) 데이터를 처리하거나 저장하는 스레드가 소비자 역할을 할 수 있다.
- 버퍼
  - 생산자가 생성한 데이터를 일시적으로 저장하는 공간이다.
  - 이 버퍼는 한정된 크기를 가지며, 생산자와 소비자가 이 버퍼를 통해 데이터를 주고 받는다.


## 문제 상황
- 생산자가 너무 빠를 때
  - 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성한다.
  - 버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.
- 소비자가 너무 빠를 때
  - 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.
  - 버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다.


## 생산자 소비자 문제
- 생산자 소비자 문제
  - 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제이다.
- 한정된 버퍼 문제
  - 이 문제는 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다.
  - 따라서 한정된 버퍼 문제라고도 한다.
- 위의 두 문제는 같은 뜻이다.


## Object - wait, notify
- 자바는 처음부터 멀티스레드를 고려하며 탄생한 언어다.
- **synchronized**를 사용한 임계 영역 안에서 락을 가지고 무한 대기하는 문제는 흥미롭게도 **Object** 클래스에 해결 방안이 있다.
  - **Object** 클래스는 이런 문제를 해결할 수 있는 **wait()**, **notify()**라는 메서드를 제공한다.


### 메서드 설명
- **Object.wait()**
  - 현재 스레드가 가진 락을 반납하고 대기(WAITING)한다.
  - 이 메서드는 현재 스레드가 **synchronized** 블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다.
    - 호출한 메서드는 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다.
  - 이렇게 대기 상태로 전환된 스레드는 다른 스레드가 **notify()** 또는 **notifyAll()**을 호출할 때까지 대기 상태를 유지한다.
- **Object.notify()**
  - 대기 중인 스레드 중 하나를 깨운다.
  - 이 메서드는 **synchronized** 블록이나 메서드에서 호출되어야 한다.
  - 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다.
    - 만약 대기 중인 스레드가 여러 개라면, 그 중 하나만이 깨워지게 된다.
- **Object.notifyAll()**
  - 대기 중인 모든 스레드를 깨운다.
  - 이 메서드 역시 **synchronized** 블록이나 메서드에서 호출되어야 하며, 모든 대기 중인 스레드가 락을 획득할 수 있는 기회를 얻게 된다.
  - 이 방법은 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.


## Object - wait, notify 한계
### 같은 종류의 스레드를 깨울 때 비효율이 발생한다.
- 생산자가 같은 생산자를 깨우거나, 소비자가 같은 소비자를 깨울 때 비효율이 발생할 수 있다는 점이다.
  - 생산자가 소비자를 깨우고, 반대로 소비자가 생산자를 깨운다면 이런 비효율은 발생하지 않는다.


### 스레드 기아
- 어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 스레드 기아 문제가 있다.