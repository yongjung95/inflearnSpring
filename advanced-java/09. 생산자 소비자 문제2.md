## 09. 생산자 소비자 문제2

## Lock Condition
- 생산자가 생산자를 깨우고, 소비자가 소비자를 깨우는 비효율 문제를 해결할 수 있는 방법.
- **synchronized** 에서 사용하는 객체 내부에 있는 모니터 락이 아니라, **ReentrantLock** 락을 뜻한다.


### Conidtion
- **Condition**은 **ReentrantLock**을 사용하는 스레드가 대기하는 스레드 대기 공간이다.
- **lock.newCondtion()** 메서드를 호출하면 스레드 대기 공간이 만들어진다.
  - 참고로 **Object.wait()** 에서 사용한 스레드 대기 공간은 모든 객체 인스턴스가 내부에 기본으로 가지고 있다.
  - 반면에 **Lock(ReentrantLock)** 을 사용하는 경우 이렇게 스레드 대기 공간을 직접 만들어서 사용해야 한다.


### condition.await()
- **Object.wait()** 와 유사한 기능이다.
- 지정한 **condtion**에 현재 스레드를 대기(WAITING) 상태로 보관한다.
- 이때 **ReentrantLock** 에서 획득한 락을 반납하고 대기 상태로 **condition**에 보관한다.


### condition.signal()
- **Object.notify()** 와 유사한 기능이다.
- 지정한 **condition**에서 대기중인 스레드를 하나 깨운다.
- 깨어난 스레드는 **condition**에서 빠져나온다.


## Condition 분리
### consumerCond
- 생산자를 위한 스레드 대기 공간


### producerCond
- 소비자를 위한 스레드 대기 공간


### 핵심
- **condition**을 분리함으로써 생산자는 소비자를 깨우고, 소비자는 생산자를 깨운다는 점이다.


## 스레드의 대기
### synchronized 대기
- 대기 1 : 락 획득 대기
  - **BLOCKED** 상태로 락 획득 대기
  - **synchronized**를 시작할 때 락이 없으면 대기
  - 다른 스레드가 **synchronized**를 빠져나갈 때 대기가 풀리며 락 획득 시도
- 대기 2 : wait() 대기
  - **WAITING** 상태로 대기
  - **wait()** 를 호출 했을 때 스레드 대기 집합에서 대기
  - 다른 스레드가 **notify()** 를 호출 했을 때 빠져나감


### 락 대기 집합
- 이곳은 락을 기다리는 **BLOCKED** 상태의 스레드들을 관리한다.
- 개념상 락 대기 집합이 1차 대기소이고, 스레드 대기 집합이 2차 대기소이다.
- 2차 대기소에 있는 스레드는 2차 대기소를 빠져나온다고 끝이 아니다.
- 1차 대기소까지 빠져나와야 임계 영역에서 로직을 수행할 수 있다.
  - 비유를 하자면 임계 영역을 안전하게 지키지 위한 2중 감옥인 것이다.
  - 스레드는 2중 감옥을 모두 탈출해야 임계 영역을 수행할 수 있다.


### 정리
- 자바의 모든 객체 인스턴스는 멀티스레드와 임계 영역을 다루기 위해 내부에 3가지 기본 요소를 가진다.
  - 모니터 락
  - 락 대기 집합(모니터 락 대기 집합)
  - 스레드 대기 집합
- 여기서 락 대기 집합이 1차 대기소이고, 스레드 대기 집합이 2차 대기소라 생각하면 된다.
  - 2차 대기소에 들어간 스레드는 2차, 1차 대기소를 모두 빠져나와야 임계 영역을 수행할 수 있다.
- 이 3가지 요소는 서로 맞물려 돌아간다.
  - **synchronized**를 사용한 임계 영역에 들어가려면 모니터 락이 필요하다.
  - 모니터 락이 없으면 락 대기 집합에 들어가서 **BLOCKED** 상태로 락을 기다린다.
  - 모니터 락을 반납하면 락 대기 잡합에 있는 스레드 중 하나가 락을 획득하고 **BLOCKED** -> **RUNNABLE** 상태가된다.
  - **wait()**를 호출해서 스레드 대기 집합에 들어가기 위해서는 모니터 락이 필요하다.
  - 스레드 대기 집합에 들어가면 모니터 락을 반납한다.
  - 스레드가 **notify()** 를 호출하면 스레드 대기 집합에 있는 스레드 중 하나가 스레드 대기 집합을 빠져나온다. 그리고 모니터 락 획득을 시도한다.
    - 모니터 락을 획득하면 임계 영역을 수행한다.
    - 모니터 락을 획득하지 못하면 락 대기 집합에 들어가서 **BLOCKED** 상태로 락을 기다린다


## synchronized vs ReentrantLock 대기
- **synchronized** 와 마찬가지로 **Lock(ReentrantLock)** 도 2가지 단계의 대기 상태가 존재한다.


### synchronized 대기
![img.png](images/synchronized%20대기.png)
- 대기 1 : 모니터 락 획득 대기
  - 자바 객체 내부의 락 대기 집합(모니터 락 대기 집합)에서 관리
  - **BLOCKED** 상태로 락 획득 대기
  - **synchronized**를 시작할 때 락이 없으면 대기
  - 다른 스레드가 **synchronized**를 빠져나갈 때 락을 획득 시도, 락을 획득하면 락 대기 집합을 빠져나감
- 대기 2 : wait() 대기
  - **wait()**를 호출 했을 때 자바 객체 내부의 스레드 대기 집합에서 관리
  - **WAITING** 상태로 대기
  - 다른 스레드가 **notify()**를 호출 했을 때 스레드 대기 집합을 빠져나감


### Lock(ReentrantLock) 대기
![img.png](images/Lock(ReentrantLock)%20대기.png)
- 대기 1 : ReentrantLock 락 획득 대기
  - **ReentrantLock**의 대기 큐에서 관리
  - **WAITING** 상태로 락 획득 대기
  - **lock.lock()** 을 호출 했을 때 락이 없으면 대기
  - 다른 스레드가 **lock.unlock()** 을 호출 했을 때 대기가 풀리면서 락 획득 시도, 락을 획득하면 대기 큐를 빠져나감
- 대기 2 : await() 대기
  - **condition.await()** 를 호출 했을 때, **condition** 객체의 스레드 대기 공간에서 관리
  - **WAITING** 상태로 대기
  - 다른 스레드가 **condition.signal()** 을 호출 했을 때 **condition** 객체의 스레드 대기 공간에서 빠져나감


## BlockingQueue
- 자바가 생산자 소비자 문제를 해결하기 위해 특별한 멀티스레드 자료 구조를 제공한다.
  - 이것은 이름 그대로 스레드를 차단(Blocking) 할 수 있는 큐다.
- 데이터 추가 차단
  - 큐가 가득 차면 데이터 추가 작업을 시도하는 스레드는 공간이 생길 때까지 차단된다.
- 데이터 획득 차단
  - 큐가 비어 있으면 획득 작업을 시도하는 스레드는 큐에 데이터가 들어올 때까지 차단된다.


### BlockingQueue의 기능
- **BlockingQueue**는 인터페이스이고, 다음과 같은 다양한 기능을 제공한다.
- 데이터 추가 메서드
  - add(), offer(), put(), offer(타임아웃)
- 데이터 획득 메서드
  - take(), poll(타입아웃), remove(..)
- **Queue**를 상속받는다.
  - 큐를 상속 받았기 때문에 추가로 큐의 기능들도 사용할 수 있다.
- 주요 메서드들만 정리함.


### BlockingQueue 인터페이스의 대표적인 구현체
- ArrayBlockingQueue
  - 배열 기반으로 구현되어 있고, 버퍼의 크기가 고정되어 있다.
- LinkedBlockingQueue
  - 링크 기반으로 구현되어 있고, 버퍼의 크기를 고정할 수도, 또는 무한하게 사용할 수도 있다.


## BlockingQueue - 기능 설명
- 실무에서 멀티스레드를 사용할 때는 응답성이 중요하다.
  - 예) 대기 상태에 있어도, 고객이 중지 요청을 하거나, 또는 너무 오래 대기한 경우 포기하고 빠져나갈 수 있는 방법이 필요하다.
- 큐가 가득 찼을 때 생각할 수 있는 선택지
  - 예외를 던진다. 예외를 받아서 처리한다.
  - 대기하지 않는다. 즉시 **false**를 반환한다.
  - 대기한다.
  - 특정 시간 만큼만 대기한다.


### BlockingQueue의 다양한 기능 - 공식 API 문서
![img.png](images/BlockingQueue의%20다양한%20기능.png)
- **Throws Exception - 대기시 예외**
  - add(e): 지정된 요소를 큐에 추가하며, 큐가 가득 차면 IllegalStateException 예외를 던진다.
  - remove(): 큐에서 요소를 제거하며 반환한다. 큐가 비어 있으면 NoSuchElementException 예외를 던진다.
  - element(): 큐의 머리 요소를 반환하지만, 요소를 큐에서 제거하지 않는다. 큐가 비어 있으면 NoSuchElementException 예외를 던진다.
- **Special Value - 대기시 즉시 반환**
  - offer(e): 지정된 요소를 큐에 추가하려고 시도하며, 큐가 가득 차면 false 를 반환한다.
  - poll(): 큐에서 요소를 제거하고 반환한다. 큐가 비어 있으면 null 을 반환한다.
  - peek(): 큐의 머리 요소를 반환하지만, 요소를 큐에서 제거하지 않는다. 큐가 비어 있으면 null 을 반환한다.
- **Blocks - 대기**
  - put(e): 지정된 요소를 큐에 추가할 때까지 대기한다. 큐가 가득 차면 공간이 생길 때까지 대기한다.
  - take(): 큐에서 요소를 제거하고 반환한다. 큐가 비어 있으면 요소가 준비될 때까지 대기한다.
  - Examine (관찰): 해당 사항 없음.
- **Times Out - 시간 대기**
  - offer(e, time, unit): 지정된 요소를 큐에 추가하려고 시도하며, 지정된 시간 동안 큐가 비워지기를 기다리다가 시간이 초과되면 false 를 반환한다.
  - poll(time, unit): 큐에서 요소를 제거하고 반환한다. 큐에 요소가 없다면 지정된 시간 동안 요소가 준비되기를 기다리다가 시간이 초과되면 null 을 반환한다.
  - Examine (관찰): 해당 사항 없음.