## 03. 영속성 관리

### JPA에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기
- **영속성 컨텍스트**


### 영속성 컨텍스트
- **JPA**를 이해하는데 가장 중요한 용어
- `엔티티를 영구 저장하는 환경`이라는 뜻
- **영속성 컨텍스트**는 논리적인 개념으로 눈에 보이지 않는다.
- **엔티티 매니저**를 통해서 영속성 컨텍스트에 접근
  - **EntityManager.persist(entity)**


### 엔티티의 생명주기
#### 비영속 (new/transient)
- **영속성 컨텍스트**와 전혀 관계가 없는 **새로운** 상태
- 객체를 생성한 상태
  - `Member member = new Member();`

#### 영속 (managed)
- **영속성 컨텍스트**에 **관리**되는 상태
- 객체를 저장한 상태
  - `em.persist(member);`

#### 준영속 (detached)
- **영속성 컨텍스트**에 저장되었다가 **분리**된 상태
  - `em.detach(member);`

#### 삭제 (removed)
- **삭제**된 상태
  - `em.remove(member);`


### 영속성 컨텍스트의 이점
#### 1차 캐시
- 데이터베이스에서 조회 및 등록된 데이터는 **영속 컨텍스트** 안에 있는 **1차 캐시**에 보관하여 필요할 때마다 조회
- 단, 동일 **트랜잭션**안에서만

#### 동일성(identity) 보장
- 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공

#### 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
- 트랜잭션을 커밋하는 순간에 데이트베이스에 모든 **SQL**을 보낸다.

#### 변경 감지 (Dirty Checking)
- **영속 컨텍스트** 안에 엔티티와 스냅샷을 비교하여 변경이 되면 **SQL**을 보낸다.

#### 지연 로딩 (Lazy Loading)


### 플러시
#### 플러시란?
- **영속성 컨텍스트**의 변경 내용을 데이터베이스에 반영

#### 플러시 발생
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

### 영속성 컨텍스트를 플러시하는 방법
- `em.flush()` 
  - 직접 호출
- 트랜잭션 커밋
  - **플러시** 자동 호출
- JPQL 쿼리 실행
  - **플러시** 자동 호출
  - 데이터베이스에 쿼리를 날리기 때문에 그 전에 **플러시**가 자동 호출된다.

#### 플러시 주의
- **영속성 컨텍스트**를 비우지 않고, 변경 내용을 데이터베이스에 동기화 하는 것이다.
- 트랜잭션이라는 작업 단위가 중요하고, 커밋 직전에만 동기화 하면 된다.


### 준영속 상태
#### 준영속 상태란?
- 영속 -> 준영속
- 영속 상태의 엔티기가 **영속성 컨텍스트**에서 분리(detached)
- **영속성 컨텍스트**가 제공하는 기능을 사용 못함

#### 준영속 상태로 만드는 방법
- `em.detach(entity)`
  - 특정 엔티티만 준영속 상태로 전환
- `em.clear()`
  - **영속성 컨텍스트**를 완전히 초기화
- `em.close()`
  - **영속성 컨텍스트**를 종료