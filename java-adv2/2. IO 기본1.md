# 2. IO 기본1
## 스트림 시작
- 자바 프로세스가 가지고 있는 데이터를 밖으로 보내려면 출력 스트림을 사용하면 되고, 반대로 외부 데이터를 자바 프로세스 안으로 가져오려면 입력 스트림을 사용하면 된다.
- 참고로 각 스트림은 단방향으로 흐른다.


### 스트림 주요 메서드
- new FileOutputStream("temp/hello.dat")
  - 파일에 데이터를 출력하는 스트림이다.
  - 파일이 없으면 파일을 자동으로 만들고, 데이터를 해당 파일에 저장한다.
  - 폴더를 만들지는 않기 때문에 폴더는 미리 만들어두어야 한다.
- write()
  - byte 단위로 값을 출력한다. 여기서는 65, 66, 67을 출력했다.
  - 참고로 ASCII 코드 집합에서 65은 A, 66은 B, 67는 C이다.
- new FileInputStream("temp/hello.dat")
  - 파일에서 데이터를 읽어오는 스트림이다.
- read()
  - 파일에서 데이터를 byte 단위로 하나씩 읽어온다.
  - 순서대로 65, 66, 67을 읽어온다.
  - 파일의 끝에 도달해서 더는 읽을 내용이 없다면 -1을 반환한다.
  - 파일의 끝(EOF, End of File)
- close()
  - 파일에 접근하는 것은 자바 입장에서 외부 자원을 사용하는 것이다. 자바에서 내부 객체는 자동으로 GC가 되지만 외부 자원은 사용 후 반드시 닫아주어야 한다.


### 부분으로 나누어 읽기 VS 전체 읽기
- `read(byte[], offset, lentgh)`
  - 스트림의 내용을 부분적으로 읽거나, 읽은 내용을 처리하면서 스트림을 계속해서 읽어야 할 경우에 적합하다.
  - 메모리 사용량을 제어할 수 있다.
  - 예시) 파일이나 스트림에서 일정한 크기의 데이터를 반복적으로 읽어야 할 때 유용하다. 예를 들어, 대용량
파일을 처리할 때, 한 번에 메모리에 로드하기보다는 이 메서드를 사용하여 파일을 조각조각 읽어들일 수 있다.
  - 100M의 파일을 1M 단위로 나누어 읽고 처리하는 방식을 사용하면 한 번에 최대 1M의 메모리만 사용한다.
- `readAllBytes()`
  - 한 번의 호출로 모든 데이터를 읽을 수 있어 편리하다.
  - 작은 파일이나 메모리에 모든 내용을 올려서 처리해야 하는 경우에 적합하다.
  - 메모리 사용량을 제어할 수 없다.
  - 큰 파일의 경우 OutOfMemoryError가 발생할 수 있다.


## InputStream, OutputStream
- 현대의 컴퓨터는 대부분 byte 단위로 데이터를 주고 받는다. 참고로 bit 단위는 너무 작기 때문에 byte 단위를 기본으로 사용한다.
- 이렇게 데이터를 주고 받는 것을 `Input/Output(I/O)`라 한다.
- 자바 내부에 있는 데이터를 `외부에 있는 파일에 저장하거나, 네트워크를 통해 전송하거나 콘솔에 출력할 때 모두 byte 단위로 데이터를 주고 받는다.`
- 만약 파일, 네트워크, 콘솔 각각 데이터를 주고 받는 방식이 다르다면 상당히 불편할 것이다.
- 또한 파일에 저장하던 내용을 네트워크에 전달하거나 콘솔에 출력하도록 변경할 때 너무 많은 코드를 변경해야 할 수 있다.
- 이런 문제를 해결하기 위해 자바는 `InputStream , OutputStream 이라는 기본 추상 클래스를 제공`한다.


### 정리
- InputStream 과 OutputStream 이 다양한 스트림들을 추상화하고 기본 기능에 대한 표준을 잡아둔 덕분에 개발자는 편리하게 입출력 작업을 수행할 수 있다. 이러한 추상화의 장점은 다음과 같다.
- 일관성
  - 모든 종류의 입출력 작업에 대해 동일한 인터페이스(여기서는 부모의 메서드)를 사용할 수 있어, 코드의
일관성이 유지된다.
- 유연성
  - 실제 데이터 소스나 목적지가 무엇인지에 관계없이 동일한 방식으로 코드를 작성할 수 있다. 
  - 예) 파일, 네트워크, 메모리 등 다양한 소스에 대해 동일한 메서드를 사용할 수 있다.
- 확장성
  - 새로운 유형의 입출력 스트림을 쉽게 추가할 수 있다.
- 재사용성
  - 다양한 스트림 클래스들을 조합하여 복잡한 입출력 작업을 수행할 수 있다. 
  - 예) BufferedInputStream 을 사용하여 성능을 향상시키거나, DataInputStream 을 사용하여 기본 데이터 타입을 쉽게 읽을 수 있다.
- 에러 처리
  - 표준화된 예외 처리 메커니즘을 통해 일관된 방식으로 오류를 처리할 수 있다.
- 참고로 InputStream , OutputStream 은 추상 클래스이다. 자바 1.0부터 제공되고, 일부 작동하는 코드도 들어있기 때문에 인터페이스가 아니라 추상 클래스로 제공된다.


## 파일 입출력과 성능 최적화 1 - 하나씩 쓰기
- 10MB 파일 하나를 쓰는데 14초, 읽는데 5초라는 매우 오랜 시간이 걸렸다.
  - 이렇게 오래 걸린 이유는 자바에서 1byte씩 디스크에 데이터를 전달하기 때문이다. 디스크는 1byte의 데이터를 받아서 1byte의 데이터를 쓴다. 이 과정을 무려 1000만 번 반복하는 것이다
- write() 나 read() 를 호출할 때마다 OS의 시스템 콜을 통해 파일을 읽거나 쓰는 명령어를 전달한다. 이러한 시스템 콜은 상대적으로 무거운 작업이다.
- HDD, SDD 같은 장치들도 하나의 데이터를 읽고 쓸 때마다 필요한 시간이 있다. HDD의 경우 더욱 느린데, 물리적으로 디스크의 회전이 필요하다.
- 이러한 무거운 작업을 무려 1000만 번 반복한다


## 파일 입출력과 성능 최적화 2 - 버퍼 활용
- 데이터를 먼저 buffer 라는 byte[] 에 담아둔다.
  - 이렇게 `데이터를 모아서 전달하거나 모아서 전달받는 용도로 사용하는 것을 버퍼`라 한다.
- 여기서는 BUFFER_SIZE 만큼 데이터를 모아서 write() 를 호출한다.
  - 예) BUFFER_SIZE 가 10이라면 10만큼 모이면 wirte() 를 호출해서 10byte 를 한 번에 스트림에 전달한다.


### 버퍼의 크기에 따른 쓰기 성능
- `많은 데이터를 한 번에 전달하면 성능을 최적화` 할 수 있다. 이렇게 되면 시스템 콜도 줄어들고, HDD, SDD 같은 장치들의 작동 횟수도 줄어든다.
  - 예) 버퍼의 크기를 1 2로 변경하면 시스템 콜 횟수는 절반으로 줄어든다.
- 그런데 버퍼의 크기가 커진다고 해서 속도가 계속 줄어들지는 않는다.
  - 왜냐하면 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 보통 4KB 또는 8KB이기 때문이다.
  - 4KB (4096 byte)
  - 8KB (8192 byte)
- 따라서 `버퍼의 크기는 보통 4KB, 8KB 정도로 잡는 것이 효율적`이다.


## 파일 입출력과 성능 최적화 3 - Buffered 스트림 쓰기
- `BufferedOutputStream 은 버퍼 기능을 내부에서 대신 처리`해준다. 
  - 따라서 단순한 코드를 유지하면서 버퍼를 사용하는 이점도 함께 누릴 수 있다.
- BufferedOutputStream 은 내부에서 단순히 버퍼 기능만 제공한다. 
  - 따라서 `반드시 대상 OutputStream이 있어야 한다.`


### 만약 버퍼에 데이터가 남아있는 상태로 close()를 호출하면 어떻게 될까?
- BufferedOutputStream 을 close() 로 닫으면 먼저 내부에서 flush() 를 호출한다. 
  - 따라서 버퍼에 남아있는 데이터를 모두 전달하고 비운다.
- 따라서 `close() 를 호출해도 남은 데이터를 안전하게 저장`할 수 있다.


### 주의! - 반드시 마지막에 연결한 스트림을 닫아야 한다.


### 기본 스트림, 보조 스트림
- FileOutputStream 과 같이 `단독으로 사용할 수 있는 스트림을 기본 스트림`이라 한다.
- BufferedOutputStream 과 같이 단독으로 사용할 수 없고, `보조 기능을 제공하는 스트림을 보조 스트림`이라 한다.
  - BufferedOutputStream 은 FileOutputStream 에 `버퍼라는 보조 기능을 제공`한다.
  - BufferedOutputStream 의 생성자를 보면 알겠지만 `반드시 FileOutputStream 같은 대상 OutputStream이 있어야 한다.`


### 정리
- BufferedOutputStream 은 버퍼 기능을 제공하는 보조 스트림이다.
- BufferedOutputStream 도 OutputStream 의 자식이기 때문에 OutputStream 의 기능을 그대로 사용
할 수 있다.
  - 물론 대부분의 기능은 재정의 된다.
  - write() 의 경우 먼저 버퍼에 쌓도록 재정의 된다.
- 버퍼의 크기만큼 데이터를 모아서 전달하기 때문에 빠른 속도로 데이터를 처리할 수 있다.


## 버퍼를 직접 다루는 것 보다 BufferedXxx의 성능이 떨어지는 이유
- 성능 비교
  - 예제1 쓰기: 14000ms (14초)
  - 예제2 쓰기: 14ms (버퍼 직접 다룸)
  - 예제3 쓰기: 102ms (BufferedXxx)
- 바로 그 이유는 `동기화` 때문이다.


### BufferedXxx 클래스의 특징
- 처음부터 멀티 스레드를 고려해서 만든 클래스이다.
  - 따라서 멀티 스레드에 안전하지만 락을 걸고 푸는 동기화 코드로 인해 성능이 약간 저하될 수 있다.
  - 하지만 싱글 스레드 상황에서는 동기화 락이 필요하지 않기 때문에 직접 버퍼를 다룰 때와 비교해서 성능이 떨어진다.
- 꼭 필요한 상황이라면 `BufferedXxx`를 참고해서 동기화 락 코드를 제거한 클래스를 직접 만들어 사용하면 된다.


## 파일 입출력과 성능 최적화 5 - 한 번에 쓰기
- 파일의 크기가 크지 않다면 간단하게 한 번에 쓰고 읽는 것도 좋은 방법이다.
- 이 방법은 성능은 가장 빠르지만, 결과적으로 `메모리를 한 번에 많이 사용하기 때문에 파일의 크기가 작아야 한다.`
- 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 보통 4KB 또는 8KB이기 때문에, 한 번에 쓴다고해서
무작정 빠른 것은 아니다.


## 정리
- 파일의 크기가 크지 않아서, 메모리 사용에 큰 영향을 주지 않는다면 쉽고 빠르게 한 번에 처리하자.
- 성능이 중요하고 큰 파일을 나누어 처리해야 한다면, 버퍼를 직접 다루자.
- 성능이 크게 중요하지 않고, 버퍼 기능이 필요하면 BufferedXxx 를 사용하자.
- BufferedXxx 는 동기화 코드가 들어있어서 스레드 안전하지만, 약간의 성능 저하가 있다.