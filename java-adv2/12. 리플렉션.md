# 12. 리플렉션 
## 클래스와 메타데이터
### 리플렉션
- 클래스가 제공하는 다양한 정보를 동적으로 분석하고 사용하는 기능을 `리플렉션(Reflection)`이라 한다.
- 리플렉션을 통해 프로그램 실행 중에 클래스, 메서드, 필드 등에 대한 정보를 얻거나, 새로운 객체를 생성하고 메서드를 호출하며, 필드의 값을 읽고 쓸 수 있다.


### 리플렉션을 통해 얻을 수 있는 정보
- 클래스의 메타데이터
  - 클래스 이름, 접근 제어자, 부모 클래스, 구현된 인터페이스 등.
- 필드 정보
  - 필드의 이름, 타입, 접근 제어자를 확인하고, 해당 필드의 값을 읽거나 수정할 수 있다.
- 메서드 정보
  - 메서드 이름, 반환 타입, 매개변수 정보를 확인하고, 실행 중에 동적으로 메서드를 호출할 수 있다.
- 생성자 정보
  - 생성자의 매개변수 타입과 개수를 확인하고, 동적으로 객체를 생성할 수 있다.


### 클래스 메타데이터 조회
- 클래스에서 찾기
  - `Class<BasicData> basicDataClass1 = BasicData.class`
- 인스턴스에서 찾기
  - ```java
    BasicData helloInstance = new BasicData();
    Class<? extends BasicData> basicDataClass2 = helloInstance.getClass();
    ```
- 문자로 찾기
  - ```java
    String className = "reflection.data.BasicData"; // 패키지명 주의
    Class<?> basicData3 = Class.forName(className);
    ```


### 기본 정보 탐색
- 클래스 메타데이터로 할 수 있는 일
  - 클래스 이름, 패키지, 부모 클래스, 구현한 인터페이스, 수정자 정보 등 다양한 정보를 획득할 수 있다.
- 참고로 수정자는 접근 제어자와 비 접근 제어자(기타 수정자)로 나눌 수 있다.
  - 접근 제어자
    - `public` , `protected` , `default ( package-private )`, `private`
  - 비 접근 제어자
    - `static` , `final` , `abstract` , `synchronized` , `volatile` 등


## 메서드 탐색과 동적 호출
### 메서드 메타데이터
- `getMethods() vs getDeclaredMethods()`
  - `getMethods()`
    - 해당 클래스와 상위 클래스에서 상속된 모든 public 메서드를 반환
  - `getDeclaredMethods()`
    - 해당 클래스에서 선언된 모든 메서드를 반환하며, 접근 제어자에 관계없이 반환.
    - 상속된 메서드는 포함하지 않음


## 필드 탐색과 값 변경
### 필드 탐색
- `fields() vs declaredFields()`
- 앞서 설명한 `getMethods() vs getDeclaredMethods()` 와 같다.
  - `fields()`
    - 해당 클래스와 상위 클래스에서 상속된 모든 public 필드를 반환
  - `declaredFields()`
    - 해당 클래스에서 선언된 모든 필드를 반환하며, 접근 제어자에 관계없이 반환. 상속된 필드는 포함하지 않음.


### 필드 값 변경
- `setAccessible(true)`
  - 필드와 메서드의 접근제어자를 변경하여 접근할 수 있도록 한다.
  - 예) `private` 접근자도 접근이 가능.


### 리플렉션과 주의사항
- 리플렉션을 활용하면 private 접근 제어자에도 직접 접근해서 값을 변경할 수 있다. 
  - 하지만 이는 객체 지향 프로그래밍의 원칙을 위반하는 행위로 간주될 수 있다. 
- private 접근 제어자는 클래스 내부에서만 데이터를 보호하고, 외부에서의 직접적인 접근을 방지하기 위해 사용된다. 
- 리플렉션을 통해 이러한 접근 제한을 무시하는 것은 캡슐화 및 유지보수성에 악영향을 미칠 수 있다. 
  - 예를 들어, 클래스의 내부 구조나 구현 세부 사항이 변경될 경우 리플렉션을 사용한 코드는 쉽게 깨질 수 있으며, 이는 예상치 못한 버그를 초래할 수 있다.


## 생성자 탐색과 객체 생성
- 리플렉션을 활용하면 생성자를 탐색하고, 또 탐색한 생성자를 사용해서 객체를 생성할 수 있다.