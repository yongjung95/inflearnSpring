# 4. IO 활용
## 회원 관리 예제2 - 파일에 보관
### 참고: 빈 컬렉션 반환
- 빈 컬렉션을 반환할 때는 `new ArrayList()` 보다는 `List.of()` 를 사용하는 것이 좋다.


### try-with-resources
- `try-with-resources` 구문을 사용해서 자동으로 자원을 정리한다.
  -  try 코드 블록이 끝나면 자동으로 `close()`가 호출되면서 자원을 정리한다.


## 회원 관리 예제3 - DataStream
- 앞서 배운 예시 중에 `DataOutputStream` , `DataInputStream` 을 떠올려보자. 
- 이 스트림들은 자바의 데이터 타입을 그대로 사용할 수 있다.
  - 따라서 자바의 타입을 그대로 사용하면서 파일에 데이터를 저장하고 불러올 수 있고, 구분자도 사용하지 않아도 된다.


### DataStream 원리
- String
    ```java
    dos.writeUTF("id1"); // 저장
    dis.readUTF(); // 조회 id1
    ```
    - readUTF() 로 문자를 읽어올 때 어떻게 id1 이라는 3글자만 정확하게 읽어올 수 있는 것일까?
    - `writeUTF()` 은 UTF-8 형식으로 문자를 저장하는데, 저장할 때 2byte를 추가로 사용해서 앞에 글자의 길이를 저장해둔다. (65535 길이까지만 사용 가능)


### 정리
- `DataStream` 덕분에 자바의 타입도 그대로 사용하고, 구분자도 제거할 수 있었다.
- 추가로 모든 데이터를 문자로 저장할 때 보다 저장 용량도 더 최적화 할 수 있다.


## 회원 관리 예제4 - ObjectStream
- `ObjectStream` 을 사용하면 이렇게 메모리에 보관되어 있는 회원 인스턴스를 파일에 편리하게 저장할 수 있다.


### 객체 직렬화
- `자바 객체 직렬화(Serialization)`는 메모리에 있는 객체 인스턴스를 바이트 스트림으로 변환하여 파일에 저장하거나 네트워크를 통해 전송할 수 있도록 하는 기능이다.
- 이 과정에서 객체의 상태를 유지하여 나중에 `역직렬화(Deserialization)`를 통해 원래의 객체로 복원할 수 있다.


### Serializable 인터페이스
- 객체 직렬화를 사용하려면 직렬화하려는 클래스는 반드시 `Serializable 인터페이스를 구현`해야 한다.
- 이 인터페이스에는 아무런 기능이 없다. 
  - 단지 직렬화 가능한 클래스라는 것을 표시하기 위한 인터페이스일 뿐이다.
- 메서드 없이 단지 표시가 목적인 인터페이스를 마커 인터페이스라 한다.


### 정리
- 객체 직렬화 덕분에 객체를 매우 편리하게 저장하고 불러올 수 있었다.
- 객체 직렬화를 사용하면 객체를 바이트로 변환할 수 있어, 모든 종류의 스트림에 전달할 수 있다.
  - 이는 파일에 저장하는 것은 물론, 네트워크를 통해 객체를 전송하는 것도 가능하게 한다. 
- 이러한 특성 때문에 초기에는 분산 시스템에서 활용되었다.
  - 그러나 객체 직렬화는 1990년대에 등장한 기술로, 초창기에는 인기가 있었지만 시간이 지나면서 여러 단점이 드러났다. 또한 대안 기술이 등장하면서 점점 그 사용이 줄어들게 되었다.
- 현재는 객체 직렬화를 거의 사용하지 않는다


## XML, JSON, 데이터베이스
### 객체 직렬화의 한계
- 객체 직렬화를 사용하지 않는 이유  
  - 버전 관리의 어려움
    - 클래스 구조가 변경되면 이전에 직렬화된 객체와의 호환성 문제가 발생한다.
    - serialVersionUID 관리가 복잡하다.
  - 플랫폼 종속성
    - 자바 직렬화는 자바 플랫폼에 종속적이어서 다른 언어나 시스템과의 상호 운용성이 떨어진다.
  - 성능 이슈
    - 직렬화/역직렬화 과정이 상대적으로 느리고 리소스를 많이 사용한다.
  - 유연성 부족
    - 직렬화된 형식을 커스터마이즈하기 어렵다.
  - 크기 효율성
    - 직렬화된 데이터의 크기가 상대적으로 크다.


### 객체 직렬화의 대안1 - XML
- 플랫폼 종속성 문제를 해결하기 위해 2000년대 초반에 XML이라는 기술이 인기를 끌었다.
- 하지만 XML은 매우 유연하고 강력했지만, 복잡성과 무거움이라는 문제가 있었다. 
  - 태그를 포함한 XML 문서의 크기가 커서 네트워크 전송 비용도 증가했다.


### 객체 직렬화의 대안2 - JSON
- JSON은 `가볍고 간결`하며, 자바스크립트와의 자연스러운 호환성 덕분에 웹 개발자들 사이에서 빠르게 확산되었다.
- 2000년대 후반, 웹 API와 RESTful 서비스가 대중화되면서 JSON은 표준 데이터 교환 포맷으로 자리 잡았다.
- XML은 데이터 구조의 복잡성과 엄격한 스키마 정의가 필요한 초기 웹 서비스와 엔터프라이즈 환경에서 중요한 역할을 했지만, 시간이 지나면서 JSON과 같은 가볍고 효율적인 데이터 형식이 더 많이 채택되었다. 
- JSON은 웹과 모바일 애플리케이션의 발전과 함께 급속히 인기를 얻었으며, 현재는 대부분의 데이터 교환에서 기본적인 포맷으로 사용되고 있다. 
- XML은 특정 영역에서 여전히 사용되지만, JSON이 현대 소프트웨어 개발의 주류로 자리 잡았다.
- 지금은 `웹 환경에서 데이터를 교환할 때 JSON이 사실상 표준 기술`이다.


### 객체 직렬화의 대안3 - Protobuf, Avro - 더 적은 용량, 더 빠른 성능
- JSON은 거의 모든 곳에서 호환이 가능하고, 사람이 읽고 쓰기 쉬운 텍스트 기반 포맷이어서 디버깅과 개발이 쉽
다.
- 만약 매우 작은 용량으로 더 빠른 속도가 필요하다면 Protobuf, Avro 같은 대안 기술이 있다.
- 이런 기술은 호환성은 떨어지지만 byte 기반에, 용량과 성능 최적화가 되어 있으므로 매우 빠르다.
- 다만 byte 기반이므로 JSON처럼 사람이 직접 읽기는 어렵다.


### 정리
- 자바 객체 직렬화는 대부분 사용하지 않는다.
- JSON이 사실상 표준이다. JSON을 먼저 고려하자.
- 성능 최적화가 매우 중요하다면 Protobuf, Avro 같은 기술을 고려하자. (대부분 JSON만 사용해도 충분하다)