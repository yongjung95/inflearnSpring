# 13. 애노테이션
## 애노테이션
- 코드에 메모를 달아놓는 것처럼 특정 정보나 지시를 추가하는 도구로, 코드에 대한 메타데이터를 표현하는 방법이다.
  - `애노테이션` 이라는 이름은 코드에 대한 추가적인 정보를 주석처럼 달아놓는다는 뜻이다.


## 애노테이션 정의
- 애노테이션은 @interface 키워드로 정의한다. 
- 애노테이션은 속성을 가질 수 있는데, 인터페이스와 비슷하게 정의한다.


### 애노테이션 정의 규칙
- 데이터 타입 
  - 기본 타입 (int, float, boolean 등)
  - String 
  - Class (메타데이터) 또는 인터페이스 
  - enum 
  - 다른 애노테이션 타입 
  - 위의 타입들의 배열 
  - 앞서 설명한 타입 외에는 정의할 수 없다. 쉽게 이야기해서 일반적인 클래스를 사용할 수 없다. 
    - 예) Member , User , MyLogger
- default 값 
  - 요소에 default 값을 지정할 수 있다.
    - 예: String value() default "기본 값을 적용합니다.";
- 요소 이름 
  - 메서드 형태로 정의된다. 
  - 괄호()를 포함하되 매개변수는 없어야 한다.
- 반환 값 
  - void 를 반환 타입으로 사용할 수 없다.
- 예외 
  - 예외를 선언할 수 없다.
- 특별한 요소 이름 
  - value 라는 이름의 요소를 하나만 가질 경우, 애노테이션 사용 시 요소 이름을 생략할 수 있다


## 메타 애노테이션
- 애노테이션을 정의하는데 사용하는 특별한 애노테이션을 메타 애노테이션이라 한다.


### @Retention
- 애노테이션의 생존 기간을 지정한다.
- `RetentionPolicy.SOURCE`
  - 소스 코드에만 남아있다. 컴파일 시점에 제거된다.
- `RetentionPolicy.CLASS`
  - 컴파일 후 class 파일까지는 남아있지만 자바 실행 시점에 제거된다. (기본 값)
- `RetentionPolicy.RUNTIME`
  - 자바 실행 중에도 남아있다. 대부분 이 설정을 사용한다.


### @Target
- 애노테이션을 적용할 수 있는 위치를 지정한다.
- 주로 TYPE , FIELD , METHOD 를 사용한다.


### @Documented
- 자바 API 문서를 만들 때 해당 애노테이션이 함께 포함되는지 지정한다. 보통 함께 사용한다.


### @Inherited
- 자식 클래스가 애노테이션을 상속 받을 수 있다.


## 애노테이션과 상속
- 모든 애노테이션은 `java.lang.annotation.Annotation` 인터페이스를 묵시적으로 상속 받는다.
- `java.lang.annotation.Annotation` 인터페이스는 개발자가 직접 구현하거나 확장할 수 있는 것이 아니라, 자바 언어 자체에서 애노테이션을 위한 기반으로 사용된다.
- 이 인터페이스는 다음과 같은 메서드를 제공한다.
  - `boolean equals(Object obj)` 
    - 두 애노테이션의 동일성을 비교한다.
  - `int hashCode()`
    - 애노테이션의 해시코드를 반환한다.
  - `String toString()`
    - 애노테이션의 문자열 표현을 반환한다.
  - `Class<? extends Annotation> annotationType()`
    - 애노테이션의 타입을 반환한다.
- 모든 애노테이션은 기본적으로 `Annotation` 인터페이스를 확장하며, 이로 인해 자바에서 애노테이션은 특별한 형태의 인터페이스로 간주된다. 
  - 하지만 자바에서 애노테이션을 정의할 때, 개발자가 명시적으로 `Annotation` 인터페이스를 상속하거나 구현할 필요는 없다. 
  - 애노테이션을 `@interface` 키워드를 통해 정의하면, 자바 컴파일러가 자동으로 `Annotation` 인터페이스를 확장하도록 처리해준다.


### 애노테이션과 상속
- 애노테이션은 다른 애노테이션이나 인터페이스를 직접 상속할 수 없다.
  - 오직 `java.lang.annotation.Annotation` 인터페이스만 상속한다.
- 따라서 애노테이션 사이에는 상속이라는 개념이 존재하지 않는다.


## @Inherited
- 애노테이션을 정의할 때 `@Inherited` 메타 애노테이션을 붙이면, 애노테이션을 적용한 클래스의 자식도 해당 애노테이션을 부여 받을 수 있다.
- 단 주의할 점으로 이 기능은 `클래스 상속에서만 작동하고, 인터페이스의 구현체에는 적용되지 않는다.`


### @Inherited가 클래스 상속에만 적용되는 이유
- `클래스 상속과 인터페이스 구현의 차이`
  - 클래스 상속은 자식 클래스가 부모 클래스의 속성과 메서드를 상속받는 개념이다. 즉, 자식 클래스는 부모 클래스의 특성을 이어받으므로, 부모 클래스에 정의된 애노테이션을 자식 클래스가 자동으로 상속받을 수 있는 논리적기반이 있다.
  - 인터페이스는 메서드의 시그니처만을 정의할 뿐, 상태나 행위를 가지지 않기 때문에, 인터페이스의 구현체가 애노테이션을 상속한다는 개념이 잘 맞지 않는다.
- ``인터페이스와 다중 구현, 다이아몬드 문제`
  - 인터페이스는 다중 구현이 가능하다. 만약 인터페이스의 애노테이션을 구현 클래스에서 상속하게 되면 여러 인터페이스의 애노테이션 간의 충돌이나 모호한 상황이 발생할 수 있다.


## 애노테이션 활용
- 각 클래스의 검증을 하는 기능으로 사용될 수 있다.
- 자바 진영에서는 애노테이션 기반 검증 기능을 Jakarta(Java) Bean Validaton이라는 이름으로 표준화 했다.
  - 다양한 검증 애노테이션과 기능이 있고, 스프링 프레임워크, JPA 같은 기술들과도 함께 사용된다.


## 자바 기본 애노테이션
### @Override
- 메서드 재정의가 정확하게 잘 되었는지 컴파일러가 체크하는데 사용한다.
- `@Override 의 @Retention(RetentionPolicy.SOURCE)` 부분을 보자.
  - `RetentionPolicy.SOURCE` 로 설정하면 컴파일 이후에 `@Override` 애노테이션은 제거된다.
  - `@Override` 는 컴파일 시점에만 사용하는 애노테이션이다. 런타임에는 필요하지 않으므로 이렇게 설정되어 있다.


### @Deprecated
- @Deprecated 는 더 이상 사용되지 않는다는 뜻이다. 
- 이 애노테이션이 적용된 기능은 사용을 권장하지 않는다.
- 활용 예)
  - 해당 요소를 사용하면 오류가 발생할 가능성이 있다.
  - 호환되지 않게 변경되거나 향후 버전에서 제거될 수 있다.
  - 더 나은 최신 대체 요소로 대체되었다.
  - 더 이상 사용되지 않는 기능이다
- `@Deprecated` 
  - 더는 사용을 권장하지 않는 요소이다.
  - `since` : 더 이상 사용하지 않게된 버전 정보
  - `forRemoval` : 미래 버전에 코드가 제거될 예정이다.


### @SuppressWarnings
- 이름 그대로 경고를 억제하는 애노테이션이다. 
- 자바 컴파일러가 문제를 경고하지만, 개발자가 해당 문제를 잘 알고 있기때문에, 더는 경고하지 말라고 지시하는 애노테이션이다.
- `@SuppressWarnings` 에 사용하는 대표적인 값
  - `all`
    - 모든 경고를 억제
  - `deprecation`
    - 사용이 권장되지 않는(deprecated) 코드를 사용할 때 발생하는 경고를 억제
  - `unchecked`
    - 제네릭 타입과 관련된 unchecked 경고를 억제
  - `serial`
    - Serializable 인터페이스를 구현할 때 serialVersionUID 필드를 선언하지 않은 경우 발생하는 경고를 억제
  - `rawtypes`
    - 제네릭 타입이 명시되지 않은(raw) 타입을 사용할 때 발생하는 경고를 억제
  - `unused`
    - 사용되지 않는 변수, 메서드, 필드 등을 선언했을 때 발생하는 경고를 억제


## 정리
- 프레임워크들은 리플렉션과 애노테이션을 활용하여 다음의 `마법 같은` 기능들을 제공
  - `의존성 주입 (Dependency Injection)`
    - 스프링은 리플렉션을 사용하여 객체의 필드나 생성자에 자동으로 의존성을 주입한다. 
    - 개발자는 단순히 `@Autowired` 애노테이션만 붙이면 된다.
  - `ORM (Object-Relational Mapping)`
    - JPA는 애노테이션을 사용하여 자바 객체와 데이터베이스 테이블 간의 매핑을 정의한다. 
    - 예) `@Entity` , `@Table` , `@Column` 등의 애노테이션으로 객체-테이블 관계를 설정한다.
  - `AOP (Aspect-Oriented Programming)`
    - 스프링은 리플렉션을 사용하여 런타임에 코드를 동적으로 주입하고, `@Aspect` , `@Before` , `@After` 등의 애노테이션으로 관점 지향 프로그래밍을 구현한다.
  - `설정의 자동화`
    - `@Configuration` , `@Bean` 등의 애노테이션을 사용하여 다양한 설정을 편리하게 적용한다.
  - `트랜잭션 관리`
    - `@Transactional` 애노테이션만으로 메서드 레벨의 DB 트랜잭션 처리가 가능해진다.