## 6. 스프링이 지원하는 프록시

### 프록시 팩토리
#### 프록시 팩토리 등장배경
- 인터페이스가 있는 경우에는 **JDK 동적 프록시**를 적용하고, 그렇지 않은 경우에는 **CGLIB**를 적용하려면 어떻게 해야할까?
- 두 기술을 함꼐 사용할 때 부가기능을 제공하기 위해 **JDK 동적 프록시**가 제공하는 **InvocationHandler**와 
**CGLIB**가 제공하는 **MethodInterceptor**를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 떄 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?


#### 프록시 팩토리란?
- 스프링은 **유사한 구체적인 기술**들이 있을 때, 그것들을 **통합해서 일관성 있게 접근**할 수 있고, 더욱 편리하게 사용할 수 있는 **추상화된 기술**을 제공한다.
- 스프링은 **동적 프록시**를 통합해서 편리하게 만들어주는 **프록시 팩토리(Proxy Factory)** 라는 기능을 제공한다.
- **프록시 팩토리**는 인터페이스가 있으면 **JDK 동적 프록시**를 사용하고, 구체 클래스만 있다면 **CGLIB**를 사용한다. 물론 이 설정을 변경할 수 있다.


#### Advice 도입
- 스프링은 두 기술을 함께 사용할 때 부가 기능을 적용할 때 **Advice** 라는 새로운 개념을 도입했다.
- 개발자는 **JDK 동적 프록시**의 **InvocationHandler** 나 **CGLIB**의 **MethodInterceptor**를 신경쓰지 않고, **Advice**만 만들면 된다.
- **Advice**를 호출하는 전용 **InvocationHandler**, **MethodInterceptor**를 내부에서 사용한다.
![img.png](images/Advice%20도입.png)


### 프록시 팩토리의 기술 선택 방법
- 대상에 인터페이스가 있으면
  - **JDK 동적 프록시**, **인터페이스 기반 프록시**
- 대상에 인터페이스가 없으면
  - **CGLIB**, **구체 클래스 기반 프록시**
- **proxyTargetClass=true**
  - **CGLIB**, **구체 클래스 기반 프록시**, 인터페이스 여부와 상관없이 **CGLIB** 사용


### 포인트컷, 어드바이스, 어드바이저 - 소개
#### 포인트컷
- 어디에 부가 기능을 적용할 지, 어디에 부가 기능을 적용하지 않을지 판단하는 **필터링 로직**이다.
- 주로 클래스와 메서드 이름으로 필터링한다.
- 이름 그대로 어떤 **포인트(Point)** 에 기능을 적용할지 하지 않을지 **잘라서(cut)** 구분하는 것이다.


#### 어드바이스
- 프록시가 호출하는 부가 기능이다.
- 단순하게 프록시 로직이라 생각하면 된다.


#### 어드바이저
- 단순하게 하나의 **포인트컷**과 하나의 **어드바이스**를 가지고 있는 것이다.
- 쉽게 이야기해서 **포인트컷1 + 어드바이스 1**이다.


#### 쉽게 기억하기
- **조언(Advice)** 을 **어디(Pointcut)** 에 할 것인가?
- **조언자(Advisor)** 는 **어디(Pointcut)** 에 **조언(Advice)** 을 해야할지 알고 있다.


#### 역할과 책임
- 이렇게 구분한 것은 역할과 책임을 명확하게 분리한 것이다.
  - **포인트컷**은 대상 여부를 확인하는 **필터** 역할만 담당한다.
  - **어드바이스**는 깔금하게 **부가 기능** 로직만 담당한다.
  - 둘이 합치면 **어드바이저**가 된다. **스프링의 어드바이저**는 하나의 **포인트컷** + 하나의 **어드바이스**로 구성된다.

![img.png](images/전체%20구조.png)