## 6. 스프링이 지원하는 프록시

### 프록시 팩토리
#### 프록시 팩토리 등장배경
- 인터페이스가 있는 경우에는 **JDK 동적 프록시**를 적용하고, 그렇지 않은 경우에는 **CGLIB**를 적용하려면 어떻게 해야할까?
- 두 기술을 함꼐 사용할 때 부가기능을 제공하기 위해 **JDK 동적 프록시**가 제공하는 **InvocationHandler**와 
**CGLIB**가 제공하는 **MethodInterceptor**를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 떄 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?


#### 프록시 팩토리란?
- 스프링은 **유사한 구체적인 기술**들이 있을 때, 그것들을 **통합해서 일관성 있게 접근**할 수 있고, 더욱 편리하게 사용할 수 있는 **추상화된 기술**을 제공한다.
- 스프링은 **동적 프록시**를 통합해서 편리하게 만들어주는 **프록시 팩토리(Proxy Factory)** 라는 기능을 제공한다.
- **프록시 팩토리**는 인터페이스가 있으면 **JDK 동적 프록시**를 사용하고, 구체 클래스만 있다면 **CGLIB**를 사용한다. 물론 이 설정을 변경할 수 있다.


#### Advice 도입
- 스프링은 두 기술을 함께 사용할 때 부가 기능을 적용할 때 **Advice** 라는 새로운 개념을 도입했다.
- 개발자는 **JDK 동적 프록시**의 **InvocationHandler** 나 **CGLIB**의 **MethodInterceptor**를 신경쓰지 않고, **Advice**만 만들면 된다.
- **Advice**를 호출하는 전용 **InvocationHandler**, **MethodInterceptor**를 내부에서 사용한다.
![img.png](images/Advice%20도입.png)


### 프록시 팩토리의 기술 선택 방법
- 대상에 인터페이스가 있으면
  - **JDK 동적 프록시**, **인터페이스 기반 프록시**
- 대상에 인터페이스가 없으면
  - **CGLIB**, **구체 클래스 기반 프록시**
- **proxyTargetClass=true**
  - **CGLIB**, **구체 클래스 기반 프록시**, 인터페이스 여부와 상관없이 **CGLIB** 사용