## 5. 동적 프록시 기술

### 리플렉션
- **동적 프록시**를 이해하기 위해서는 **자바의 리플렉션** 기술을 이해해야 한다.
- **리플렉션이란?**
  - 실행 중인 프로그램 내부의 클래스, 메소드, 필드 등의 정보를 조사하고 조작할 수 있는 기능.
  - 컴파일 타임에 알 수 없는 클래스나 메소드에 동적으로 접근하고 조작할 때 유용하다.
  - 주로 런타임에서 객체의 타입을 확인하거나, 동적으로 클래스를 로드하고 인스턴스를 생성하는 등의 작업에 사용.
- **주의**
  - **리플렉션**을 사용하면 클래스와 메서드의 메타정보를 사용해서 애플리케이션을 동적으로 유연하게 만들 수 있지만, **런타임에 동작하기 때문에 컴파일 시점에 
  오류**를 잡을 수 없다.
  - 따라서 일반적으로 사용하면 안되고, **프레임워크 개발이나 또는 매우 일반적인 공통 처리**가 필요할 때 부분적으로 주의해서 사용해야 한다.


### 동적 프록시
- **프록시**를 적용하기 위해 적용 대상의 숫자만큼 많은 **프록시 클래스**를 만들어야 했다.
- **동적 프록시** 기술을 사용하면 개발자가 직접 **프록시 클래스**를 만들지 않아도, **프록시 객체**를 동적으로 **런타임**에 개발자 대신 만들어주고,
 원하는 실행 로직을 지정할 수 있다.


### JDK 동적 프록시
- 자바 언어가 기본으로 제공하는 **프록시 기술**
- **인터페이스**를 기반으로 **프록시**를 **동적**으로 만들어준다. **인터페이스가 필수!**
- **InvocationHandler** 인터페이스를 구현해서 작성하면 된다.
  ```java
  public interface InvocationHandler {
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
  }
  ``` 
  - **Object Proxy** : 프록시 자신
  - **Method method** : 호출한 메서드
  - **Object[] args** : 메서드를 호출할 때 전달할 인수

- 클래스 의존 관계 - JDK 동적 프록시 도입 후
  ![img.png](images/클래스%20의존%20관계%20-%20JDK%20동적%20프록시%20도입%20후.png)
- **정리**
  - **JDK 동적 프록시 기술** 덕분에 적용 대상만큼 **프록시 객체**를 만들지 않아도 된다.
  - 같은 부가 기능 로직은 한 번만 개발해서 공통적으로 적용할 수 있고, 적용 대상이 100개여도 **동적 프록시**를 통해서 생성하고, 
  각각 필요한 **InvocationHandler**만 만들어서 넣어주면 된다.
  - 결과적으로 **프록시 클래스**를 수 없이 만들어야 하는 문제도 해결하고, 부가 기능 로직도 하나의 클래스에 모아서 **단일 책임 원칙(SRP)** 도 지킬 수 있다.


### CGLIB
#### CGLIB 이란?
- Code Generator Library
- 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다.
- 인터페이스가 없어도, 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다.
- 원래 외부 라이브러리인데, 스프링 프레임워크가 스프링 내부 소스 코드에 포함해서 스프링을 사용한다면 별도의 추가없이 사용 가능.

#### CGLIB 제약
- **클래스 기반 프록시**는 상속을 사용하기 때문에 몇 가지 제약이 있다.
- 부모 클래스의 생성자를 체크해야 한다.
  - **CGLIB**는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
- 클래스에 **final** 키워드가 붙으면 상속이 불가능하다.
  - **CGLIB**에서는 예외가 발생한다.
- 메서드에 **final** 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.
  - **CGLIB**에서는 프록시 로직이 동작하지 않는다.