## 2. 쓰레드 로컬 - ThreadLocal

* ### 동시성 문제
  * 여러 `쓰레드`가 동시에 같은 `인스턴스`의 필드 값을 변경하면서 발생하는 문제.
  * 여러 `쓰레드`가 같은 `인스턴스`의 필드에 접근해야 하기 때문에 `트래픽`이 적은 상황에서는 확률상 발생 X,
  트래픽이 많아질 수 록 자주 발생한다.
  * 특히 `스프링 빈` 처럼 `싱글톤 객체`의 필드를 변경하며 사용할 때 조심해야 한다.


* ### 쓰레드 로컬
  * 동시성 문제를 해결하기 위한 방법.
  * 해당 쓰레드만 접근할 수 있는 `특별한 저장소`를 말한다.
  * 자바는 언어차원에서 쓰레드 로컬을 지원하기 위한 `java.lang.ThreadLocal` 클래스를 제공한다
  * 사용법 
    * ```java
      private ThreadLocal<String> nameStore = new ThreadLocal<>();
      ```
    * 값 저장: `ThreadLocal.set(xxx)`
    * 값 조회: `ThreadLocal.get()`
    * 값 제거: `ThreadLocal.remove()`
  * 주의
    * 해당 `쓰레드`가 `쓰레드 로컬`을 모두 사용하고 나면 `ThreadLocal.remove()`를 호출해서 `쓰레드 로컬`에 저장된 값을 제거해주어야 한다.


* ### 쓰레드 로컬 주의사항
  * `쓰레드 로컬`의 값을 사용 후 제거하지 않고, 그냥 두면 `WAS(톰캣)`처럼 `쓰레드 풀`을 사용하는 경우에 심각한 문제가 발생할 수 있다.
  * 예시)
    * 사용자A 저장 요청
    ![img.png](images/사용자A%20저장.png)
    * 사용자A 저장 요청 종료
    ![img.png](images/사용자A%20저장%20요청%20종료.png)
    * 사용자B 조회 요청
    ![img.png](images/사용자B%20조회%20요청.png)
  * 결과적으로 사용자B는 사용자A의 데이터를 확인하게 되는 `심각한 문제`가 발생하게 된다.
  * 이런 문제를 예방하려면 사용자A의 요청이 끝날 때 `쓰레드 로컬`의 값을 `ThreadLocal.remove()` 를 통해서 꼭 제거해야 한다.